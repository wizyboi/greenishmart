"use strict";(self.webpackChunkjupyter_web=self.webpackChunkjupyter_web||[]).push([[4644],{34644:(K,O,g)=>{g.r(O),g.d(O,{render:()=>re});var E=g(53420),N=g(79487),h=(g(11930),g(9681)),W=g(25333),t=(g(77437),g(50027),g(62477),g(3685)),Q=g(20222),b=g(94518),I=g(38884),J=g(99211);g(91650);function m(n){var r={options:{directed:n.isDirected(),multigraph:n.isMultigraph(),compound:n.isCompound()},nodes:z(n),edges:$(n)};return b.Z(n.graph())||(r.value=I.Z(n.graph())),r}function z(n){return J.Z(n.nodes(),function(r){var e=n.node(r),c=n.parent(r),i={v:r};return b.Z(e)||(i.value=e),b.Z(c)||(i.parent=c),i})}function $(n){return J.Z(n.edges(),function(r){var e=n.edge(r),c={v:r.v,w:r.w};return b.Z(r.name)||(c.name=r.name),b.Z(e)||(c.value=e),c})}var k=g(75788),l=new Map,p=new Map,R=new Map,L=(0,t.eW)(()=>{p.clear(),R.clear(),l.clear()},"clear"),Z=(0,t.eW)((n,r)=>{const e=p.get(r)||[];return t.cM.trace("In isDescendant",r," ",n," = ",e.includes(n)),e.includes(n)},"isDescendant"),q=(0,t.eW)((n,r)=>{const e=p.get(r)||[];return t.cM.info("Descendants of ",r," is ",e),t.cM.info("Edge is ",n),n.v!==r&&n.w!==r&&(e?e.includes(n.v)||Z(n.v,r)||Z(n.w,r)||e.includes(n.w):(t.cM.debug("Tilt, ",r,",not in descendants"),!1))},"edgeInCluster"),G=(0,t.eW)((n,r,e,c)=>{t.cM.warn("Copying children of ",n,"root",c,"data",r.node(n),c);const i=r.children(n)||[];n!==c&&i.push(n),t.cM.warn("Copying (nodes) clusterId",n,"nodes",i),i.forEach(o=>{if(r.children(o).length>0)G(o,r,e,c);else{const a=r.node(o);t.cM.info("cp ",o," to ",c," with parent ",n),e.setNode(o,a),c!==r.parent(o)&&(t.cM.warn("Setting parent",o,r.parent(o)),e.setParent(o,r.parent(o))),n!==c&&o!==n?(t.cM.debug("Setting parent",o,n),e.setParent(o,n)):(t.cM.info("In copy ",n,"root",c,"data",r.node(n),c),t.cM.debug("Not Setting parent for node=",o,"cluster!==rootId",n!==c,"node!==clusterId",o!==n));const u=r.edges(o);t.cM.debug("Copying Edges",u),u.forEach(d=>{t.cM.info("Edge",d);const M=r.edge(d.v,d.w,d.name);t.cM.info("Edge data",M,c);try{q(d,c)?(t.cM.info("Copying as ",d.v,d.w,M,d.name),e.setEdge(d.v,d.w,M,d.name),t.cM.info("newGraph edges ",e.edges(),e.edge(e.edges()[0]))):t.cM.info("Skipping copy of edge ",d.v,"--\x3e",d.w," rootId: ",c," clusterId:",n)}catch(y){t.cM.error(y)}})}t.cM.debug("Removing node",o),r.removeNode(o)})},"copy"),H=(0,t.eW)((n,r)=>{const e=r.children(n);let c=[...e];for(const i of e)R.set(i,n),c=[...c,...H(i,r)];return c},"extractDescendants"),ee=(0,t.eW)((n,r,e)=>{const c=n.edges().filter(d=>d.v===r||d.w===r),i=n.edges().filter(d=>d.v===e||d.w===e),o=c.map(d=>({v:d.v===r?e:d.v,w:d.w===r?r:d.w})),a=i.map(d=>({v:d.v,w:d.w}));return o.filter(d=>a.some(M=>d.v===M.v&&d.w===M.w))},"findCommonEdges"),P=(0,t.eW)((n,r,e)=>{const c=r.children(n);if(t.cM.trace("Searching children of id ",n,c),c.length<1)return n;let i;for(const o of c){const a=P(o,r,e),u=ee(r,e,a);if(a){if(!(u.length>0))return a;i=a}}return i},"findNonClusterChild"),U=(0,t.eW)(n=>l.has(n)&&l.get(n).externalConnections&&l.has(n)?l.get(n).id:n,"getAnchorId"),ne=(0,t.eW)((n,r)=>{if(!n||r>10)t.cM.debug("Opting out, no graph ");else{t.cM.debug("Opting in, graph "),n.nodes().forEach(function(e){n.children(e).length>0&&(t.cM.warn("Cluster identified",e," Replacement id in edges: ",P(e,n,e)),p.set(e,H(e,n)),l.set(e,{id:P(e,n,e),clusterData:n.node(e)}))}),n.nodes().forEach(function(e){const c=n.children(e),i=n.edges();c.length>0?(t.cM.debug("Cluster identified",e,p),i.forEach(o=>{Z(o.v,e)^Z(o.w,e)&&(t.cM.warn("Edge: ",o," leaves cluster ",e),t.cM.warn("Descendants of XXX ",e,": ",p.get(e)),l.get(e).externalConnections=!0)})):t.cM.debug("Not a cluster ",e,p)});for(let e of l.keys()){const c=l.get(e).id,i=n.parent(c);i!==e&&l.has(i)&&!l.get(i).externalConnections&&(l.get(e).id=i)}n.edges().forEach(function(e){const c=n.edge(e);t.cM.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),t.cM.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(n.edge(e)));let i=e.v,o=e.w;if(t.cM.warn("Fix XXX",l,"ids:",e.v,e.w,"Translating: ",l.get(e.v)," --- ",l.get(e.w)),l.get(e.v)||l.get(e.w)){if(t.cM.warn("Fixing and trying - removing XXX",e.v,e.w,e.name),i=U(e.v),o=U(e.w),n.removeEdge(e.v,e.w,e.name),i!==e.v){const a=n.parent(i);l.get(a).externalConnections=!0,c.fromCluster=e.v}if(o!==e.w){const a=n.parent(o);l.get(a).externalConnections=!0,c.toCluster=e.w}t.cM.warn("Fix Replacing with XXX",i,o,e.name),n.setEdge(i,o,c,e.name)}}),t.cM.warn("Adjusted Graph",m(n)),Y(n,0),t.cM.trace(l)}},"adjustClustersAndEdges"),Y=(0,t.eW)((n,r)=>{if(t.cM.warn("extractor - ",r,m(n),n.children("D")),r>10)return void t.cM.error("Bailing out");let e=n.nodes(),c=!1;for(const i of e){const o=n.children(i);c=c||o.length>0}if(c){t.cM.debug("Nodes = ",e,r);for(const i of e)if(t.cM.debug("Extracting node",i,l,l.has(i)&&!l.get(i).externalConnections,!n.parent(i),n.node(i),n.children("D")," Depth ",r),l.has(i))if(!l.get(i).externalConnections&&n.children(i)&&n.children(i).length>0){t.cM.warn("Cluster without external connections, without a parent and with children",i,r);let a="TB"===n.graph().rankdir?"LR":"TB";l.get(i)?.clusterData?.dir&&(a=l.get(i).clusterData.dir,t.cM.warn("Fixing dir",l.get(i).clusterData.dir,a));const u=new k.k({multigraph:!0,compound:!0}).setGraph({rankdir:a,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});t.cM.warn("Old graph before copy",m(n)),G(i,n,u,i),n.setNode(i,{clusterNode:!0,id:i,clusterData:l.get(i).clusterData,label:l.get(i).label,graph:u}),t.cM.warn("New graph after copy node: (",i,")",m(u)),t.cM.debug("Old graph after copy",m(n))}else t.cM.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!l.get(i).externalConnections," no parent: ",!n.parent(i)," children ",n.children(i)&&n.children(i).length>0,n.children("D"),r),t.cM.debug(l);else t.cM.debug("Not a cluster",i,r);e=n.nodes(),t.cM.warn("New list of nodes",e);for(const i of e){const o=n.node(i);t.cM.warn(" Now next level",i,o),o?.clusterNode&&Y(o.graph,r+1)}}else t.cM.debug("Done, no node has children",n.nodes())},"extractor"),j=(0,t.eW)((n,r)=>{if(0===r.length)return[];let e=Object.assign([],r);return r.forEach(c=>{const i=n.children(c),o=j(n,i);e=[...e,...o]}),e},"sorter"),te=(0,t.eW)(n=>j(n,n.children()),"sortNodesByHierarchy"),F=(0,t.eW)(function(){var n=(0,E.Z)(function*(r,e,c,i,o,a){t.cM.warn("Graph in recursive render:XAX",m(e),o);const u=e.graph().rankdir;t.cM.trace("Dir in recursive render - dir:",u);const d=r.insert("g").attr("class","root");e.nodes()?t.cM.info("Recursive render XXX",e.nodes()):t.cM.info("No nodes found for",e),e.edges().length>0&&t.cM.info("Recursive edges",e.edge(e.edges()[0]));const M=d.insert("g").attr("class","clusters"),y=d.insert("g").attr("class","edgePaths"),C=d.insert("g").attr("class","edgeLabels"),X=d.insert("g").attr("class","nodes");yield Promise.all(e.nodes().map(function(){var w=(0,E.Z)(function*(f){const s=e.node(f);if(void 0!==o){const v=JSON.parse(JSON.stringify(o.clusterData));t.cM.trace("Setting data for parent cluster XXX\n Node.id = ",f,"\n data=",v.height,"\nParent cluster",o.height),e.setNode(o.id,v),e.parent(f)||(t.cM.trace("Setting parent",f,o.id),e.setParent(f,o.id,v))}if(t.cM.info("(Insert) Node XXX"+f+": "+JSON.stringify(e.node(f))),s?.clusterNode){t.cM.info("Cluster identified XBX",f,s.width,e.node(f));const{ranksep:v,nodesep:D}=e.graph();s.graph.setGraph({...s.graph.graph(),ranksep:v+25,nodesep:D});const S=yield F(X,s.graph,c,i,e.node(f),a),V=S.elem;(0,h.jr)(s,V),s.diff=S.diff||0,t.cM.info("New compound node after recursive render XAX",f,"width",s.width,"height",s.height),(0,h.Yn)(V,s)}else e.children(f).length>0?(t.cM.trace("Cluster - the non recursive path XBX",f,s.id,s,s.width,"Graph:",e),t.cM.trace(P(s.id,e)),l.set(s.id,{id:P(s.id,e),node:s})):(t.cM.trace("Node - the non recursive path XAX",f,X,e.node(f),u),yield(0,h.Lf)(X,e.node(f),{config:a,dir:u}))});return function(f){return w.apply(this,arguments)}}())),yield(0,t.eW)((0,E.Z)(function*(){const w=e.edges().map(function(){var f=(0,E.Z)(function*(s){const v=e.edge(s.v,s.w,s.name);t.cM.info("Edge "+s.v+" -> "+s.w+": "+JSON.stringify(s)),t.cM.info("Edge "+s.v+" -> "+s.w+": ",s," ",JSON.stringify(e.edge(s))),t.cM.info("Fix",l,"ids:",s.v,s.w,"Translating: ",l.get(s.v),l.get(s.w)),yield(0,N.I_)(C,v)});return function(s){return f.apply(this,arguments)}}());yield Promise.all(w)}),"processEdges")(),t.cM.info("Graph before layout:",JSON.stringify(m(e))),t.cM.info("############################################# XXX"),t.cM.info("###                Layout                 ### XXX"),t.cM.info("############################################# XXX"),(0,Q.bK)(e),t.cM.info("Graph after layout:",JSON.stringify(m(e)));let B=0,{subGraphTitleTotalMargin:A}=(0,W.L)(a);return yield Promise.all(te(e).map(function(){var w=(0,E.Z)(function*(f){const s=e.node(f);if(t.cM.info("Position XBX => "+f+": ("+s.x,","+s.y,") width: ",s.width," height: ",s.height),s?.clusterNode)s.y+=A,t.cM.info("A tainted cluster node XBX1",f,s.id,s.width,s.height,s.x,s.y,e.parent(f)),l.get(s.id).node=s,(0,h.aH)(s);else if(e.children(f).length>0){t.cM.info("A pure cluster node XBX1",f,s.id,s.x,s.y,s.width,s.height,e.parent(f)),s.height+=A,e.node(s.parentId);const v=s?.padding/2||0,D=s?.labelBBox?.height||0,S=D-v||0;t.cM.debug("OffsetY",S,"labelHeight",D,"halfPadding",v),yield(0,h.us)(M,s),l.get(s.id).node=s}else{const v=e.node(s.parentId);s.y+=A/2,t.cM.info("A regular node XBX1 - using the padding",s.id,"parent",s.parentId,s.width,s.height,s.x,s.y,"offsetY",s.offsetY,"parent",v,v?.offsetY,s),(0,h.aH)(s)}});return function(f){return w.apply(this,arguments)}}())),e.edges().forEach(function(w){const f=e.edge(w);t.cM.info("Edge "+w.v+" -> "+w.w+": "+JSON.stringify(f),f),f.points.forEach(S=>S.y+=A/2);const s=e.node(w.v);var v=e.node(w.w);const D=(0,N.QP)(y,f,l,c,s,v,i);(0,N.Jj)(f,D)}),e.nodes().forEach(function(w){const f=e.node(w);t.cM.info(w,f.type,f.diff),f.isGroup&&(B=f.diff)}),t.cM.warn("Returning from recursive render XAX",d,B),{elem:d,diff:B}});return function(r,e,c,i,o,a){return n.apply(this,arguments)}}(),"recursiveRender"),re=(0,t.eW)(function(){var n=(0,E.Z)(function*(r,e){const c=new k.k({multigraph:!0,compound:!0}).setGraph({rankdir:r.direction,nodesep:r.config?.nodeSpacing||r.config?.flowchart?.nodeSpacing||r.nodeSpacing,ranksep:r.config?.rankSpacing||r.config?.flowchart?.rankSpacing||r.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),i=e.select("g");(0,N.DQ)(i,r.markers,r.type,r.diagramId),(0,h.gU)(),(0,N.ZH)(),(0,h.ZH)(),L(),r.nodes.forEach(a=>{c.setNode(a.id,{...a}),a.parentId&&c.setParent(a.id,a.parentId)}),t.cM.debug("Edges:",r.edges),r.edges.forEach(a=>{if(a.start===a.end){const u=a.start,d=u+"---"+u+"---1",M=u+"---"+u+"---2",y=c.node(u);c.setNode(d,{domId:d,id:d,parentId:y.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),c.setParent(d,y.parentId),c.setNode(M,{domId:M,id:M,parentId:y.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),c.setParent(M,y.parentId);const C=structuredClone(a),X=structuredClone(a),x=structuredClone(a);C.label="",C.arrowTypeEnd="none",C.id=u+"-cyclic-special-1",X.arrowTypeStart="none",X.arrowTypeEnd="none",X.id=u+"-cyclic-special-mid",x.label="",y.isGroup&&(C.fromCluster=u,x.toCluster=u),x.id=u+"-cyclic-special-2",x.arrowTypeStart="none",c.setEdge(u,d,C,u+"-cyclic-special-0"),c.setEdge(d,M,X,u+"-cyclic-special-1"),c.setEdge(M,u,x,u+"-cyc<lic-special-2")}else c.setEdge(a.start,a.end,{...a},a.id)}),t.cM.warn("Graph at first:",JSON.stringify(m(c))),ne(c),t.cM.warn("Graph after XAX:",JSON.stringify(m(c)));const o=(0,t.nV)();yield F(i,c,r.type,r.diagramId,void 0,o)});return function(r,e){return n.apply(this,arguments)}}(),"render")},38884:(K,O,g)=>{g.d(O,{Z:()=>h});var E=g(69052);const h=function T(W){return(0,E.Z)(W,4)}}}]);